import M from'jsonwebtoken';import {create}from'superstruct';import g from'bcrypt';import l from'crypto';var k=Object.defineProperty;var i=(t,o)=>{for(var e in o)k(t,e,{get:o[e],enumerable:true});};var w={};i(w,{authentication:()=>p,errorHandler:()=>d,responseHandler:()=>y,routeLog:()=>x,validateSchema:()=>m});var x=(t,o,e)=>{let r=new Date().toISOString(),s=t.ip??t.socket.remoteAddress??"unknown";console.log(`\x1B[0;36m[${r}] \x1B[0;35m[${s}] \x1B[0;33m${t.method} \x1B[0m${t.path}`),e();};var y=(t,o,e)=>{o.ok=r=>{o.json({data:r});},e();};var d={};i(d,{api:()=>j,www:()=>S});var j=(t,o,e,r)=>{e.statusCode===200&&e.status(500),t instanceof Error&&JSON.stringify(t)==="{}"?e.json({error:{name:t.name,message:t.message}}):e.json({error:t});};var S=(t,o)=>(e,r,s,n)=>{let a;t&&typeof t=="object"&&(a=t[s.statusCode]);let c;o?typeof o=="string"?c=o:c=o[s.statusCode]:e instanceof Error&&(c=e.message),c??="Unknown error",s.send(`
      <script>
        alert("${c}");
        ${a?`window.location.replace("${a}")`:"history.back()"}
      </script>
    `);};var p={};i(p,{jwt:()=>C,local:()=>E});var E=(t,o,e)=>{let r=t.ip??t.socket.remoteAddress;if(r!=="::1"&&r!=="localhost")throw o.status(401),new Error("Unauthorized");e();};var C=(t,o)=>(e,r,s)=>{let n=e.headers.authorization?.split(" ")[1];if(!n&&o&&(n=e.signedCookies?.[o]??e.cookies?.[o]),!n)throw r.status(401),new Error("No authorization header or cookie");try{let a=M.verify(n,t);e.jwt={token:n,decoded:a};}catch(a){throw r.status(401),a}s();};var m={};i(m,{joi:()=>$,superstruct:()=>B,zod:()=>T});var $=t=>async(o,e,r)=>{try{o.body=await t.validateAsync(o.body);}catch(s){throw e.status(422),s}r();};var B=t=>(o,e,r)=>{try{o.body=create(o.body,t);}catch(s){throw e.status(422),s}r();};var T=t=>async(o,e,r)=>{try{o.body=await t.parseAsync(o.body);}catch(s){throw e.status(422),s}r();};var b={};i(b,{password:()=>u});var u={};i(u,{bcrypt:()=>f,hmac:()=>h});var f={};i(f,{hash:()=>_,verify:()=>z});var _=async t=>g.hash(t,10),z=async(t,o)=>g.compare(t,o);var h={};i(h,{hash:()=>H,verify:()=>R});var H=(t,o="sha256",e="base64")=>{let r=l.randomBytes(16),s=l.createHmac(o,r).update(t);return Buffer.concat([r,s.digest()]).toString(e)},R=(t,o,e="sha256",r="base64")=>{let s=Buffer.from(o,r),[n,a]=[s.subarray(0,16),s.subarray(16)],c=l.createHmac(e,n).update(t);return a.toString(r)===c.digest(r)};export{w as middleware,b as utils};